<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŒ—é‚®å­¦å­é—¯å…³è®°</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #f5f5f5;
            color: #222;
            font-family: 'Segoe UI', Arial, sans-serif;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            margin: 0 auto;
            width: 480px;
            height: 700px;
            background: #e3eafc;
            border: 2px solid #2c3e50;
            box-shadow: 0 0 20px #b0c4de;
        }

        canvas {
            display: block;
            background: #e3eafc;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 2;
            pointer-events: none;
        }

        #ui span {
            margin: 0 10px;
            font-size: 18px;
        }

        #upgrade-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fffbe6;
            border: 2px solid #2c3e50;
            border-radius: 10px;
            padding: 30px 20px 20px 20px;
            z-index: 10;
            display: none;
            min-width: 320px;
            text-align: center;
            box-shadow: 0 0 20px #b0c4de;
        }

        #upgrade-panel h2 {
            margin-top: 0;
        }

        .upgrade-option {
            background: #e3eafc;
            border: 1px solid #8faadc;
            border-radius: 6px;
            margin: 10px 0;
            padding: 12px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.2s;
        }

        .upgrade-option:hover {
            background: #b0c4de;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fffbe6;
            border: 2px solid #2c3e50;
            border-radius: 10px;
            padding: 30px 40px;
            z-index: 20;
            display: none;
            text-align: center;
            box-shadow: 0 0 20px #b0c4de;
        }

        #game-over h2 {
            margin-top: 0;
        }

        #game-over button {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 18px;
            background: #4CAF50;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #game-over button:hover {
            background: #388e3c;
        }

        @media (max-width: 700px) {
            #game-container {
                width: 100vw;
                height: 100vh;
            }
        }

        #virtual-joystick {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 320px;
            height: 220px;
            z-index: 10;
            user-select: none;
            touch-action: none;
            opacity: 0.8;
            display: none;
            /* ä»…åœ¨ç§»åŠ¨ç«¯æ˜¾ç¤º */
        }

        .vj-row {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }

        .vj-btn {
            width: 90px;
            height: 90px;
            margin: 0 10px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid #fff;
            border-radius: 20px;
            font-size: 48px;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, border 0.2s;
        }

        .vj-btn.active {
            background: rgba(76, 175, 80, 0.5);
            border: 3px solid #4CAF50;
        }

        /* åœ¨<head>å†…è¿½åŠ CSSåŠ¨ç”» */
        @keyframes pop {
            0% {
                transform: translateY(0) scale(1.2);
                opacity: 1;
                text-shadow: 0 0 8px #fff, 0 0 2px #000
            }

            60% {
                transform: translateY(-40px) scale(1.5);
                opacity: 0.9
            }

            100% {
                transform: translateY(-60px) scale(1.8);
                opacity: 0
            }
        }
    </style>
</head>

<body>
    <div id="game-container">
        <div id="start-panel"
            style="position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(135deg,#e3eafc 0%,#fffbe6 100%);z-index:100;display:flex;flex-direction:column;align-items:center;justify-content:center;">
            <div
                style="background:#fffbe6;border-radius:18px;padding:36px 32px 28px 32px;box-shadow:0 4px 32px #b0c4de;min-width:320px;text-align:center;">
                <h1 style="margin-bottom:18px;font-size:2.2em;color:#2c3e50;letter-spacing:2px;">åŒ—é‚®å­¦å­é—¯å…³è®°</h1>
                <div style="font-size:1.2em;margin-bottom:10px;color:#333;font-weight:500;">å¼€æ³°å¸…ä¸å¸…ï¼Ÿ</div>
                <div style="font-size:1em;color:#888;margin-bottom:18px;">ï¼ˆç­”å¯¹åå¯è·å¾—ä¸‰ä¸ªå¢ç›Šï¼‰</div>
                <div style="margin-bottom:18px;">
                    <button id="btn-yes"
                        style="font-size:1.1em;padding:10px 36px;margin-right:24px;background:#4caf50;color:#fff;border:none;border-radius:8px;box-shadow:0 2px 8px #b0c4de;cursor:pointer;transition:background 0.2s;">å¯¹</button>
                    <button id="btn-no"
                        style="font-size:1.1em;padding:10px 36px;background:#e57373;color:#fff;border:none;border-radius:8px;box-shadow:0 2px 8px #b0c4de;cursor:pointer;transition:background 0.2s;">å¦</button>
                </div>
                <div id="answer-tip" style="font-size:1em;color:#388e3c;height:24px;margin-bottom:18px;"></div>
                <button id="btn-start"
                    style="font-size:1.2em;padding:12px 48px;background:#1976d2;color:#fff;border:none;border-radius:10px;box-shadow:0 2px 8px #b0c4de;cursor:pointer;transition:background 0.2s;"
                    disabled>å¼€å§‹æ¸¸æˆ</button>
            </div>
        </div>
        <canvas id="game-canvas" width="480" height="700"></canvas>
        <div id="ui">
            <span id="score">ç»©ç‚¹: 0</span>
            <span id="level">å¹´çº§: 1</span>
            <span id="exp">å­¦åˆ†: 0/10</span>
            <span id="wave">å­¦æœŸ: 1</span>
            <span id="hp">ä½“åŠ›: 3</span>
        </div>
        <div id="weapon-bar"
            style="position:absolute;top:10px;right:10px;width:280px;background:rgba(255,255,255,0.95);z-index:5;padding:8px;font-size:13px;box-shadow:0 2px 12px #b0c4de;border-radius:12px;border:1px solid #b0c4de;max-height:400px;overflow-y:auto;display:block;">
            <button id="toggle-weapon-bar"
                style="position:absolute;top:-8px;right:-8px;width:24px;height:24px;background:#e57373;color:#fff;border:none;border-radius:50%;font-size:16px;cursor:pointer;box-shadow:0 2px 4px #b0c4de;z-index:6;">Ã—</button>
            <div id="weapon-content"></div>
        </div>
        <button id="show-weapon-bar"
            style="position:absolute;top:10px;right:10px;width:40px;height:40px;background:#4caf50;color:#fff;border:none;border-radius:50%;font-size:20px;cursor:pointer;box-shadow:0 2px 8px #b0c4de;z-index:5;display:none;">ğŸ“Š</button>
        <div id="upgrade-panel">
            <h2>è¯¾ç¨‹å‡çº§ï¼è¯·é€‰æ‹©ä¸€é¡¹</h2>
            <div id="upgrade-options"></div>
        </div>
        <div id="game-over">
            <h2>å­¦ä¸šç»“æŸ</h2>
            <div id="final-score"></div>
            <button onclick="restartGame()">é‡æ–°å¼€å­¦</button>
        </div>
        <div id="virtual-joystick">
            <div class="vj-row">
                <div class="vj-btn" data-dir="up">â–²</div>
            </div>
            <div class="vj-row">
                <div class="vj-btn" data-dir="left">â—€</div>
                <div class="vj-btn" data-dir="down">â–¼</div>
                <div class="vj-btn" data-dir="right">â–¶</div>
            </div>
        </div>
    </div>
    <script>
        let hpFlashTimer = 0;
        let vampCooldown = 0;
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        let lastFrameTime = performance.now();

        // UI
        const scoreSpan = document.getElementById('score');
        const levelSpan = document.getElementById('level');
        const expSpan = document.getElementById('exp');
        const waveSpan = document.getElementById('wave');
        const hpSpan = document.getElementById('hp');
        const upgradePanel = document.getElementById('upgrade-panel');
        const upgradeOptionsDiv = document.getElementById('upgrade-options');
        const gameOverDiv = document.getElementById('game-over');
        const finalScoreDiv = document.getElementById('final-score');
        const weaponBar = document.getElementById('weapon-bar');
        const weaponContent = document.getElementById('weapon-content');
        const toggleWeaponBar = document.getElementById('toggle-weapon-bar');

        // å‚æ•°æ æ”¶èµ·/å±•å¼€åŠŸèƒ½
        toggleWeaponBar.onclick = function () {
            weaponBar.style.display = 'none';
            document.getElementById('show-weapon-bar').style.display = 'block';
        };

        // æ˜¾ç¤ºå‚æ•°æ æŒ‰é’®
        document.getElementById('show-weapon-bar').onclick = function () {
            weaponBar.style.display = 'block';
            this.style.display = 'none';
        };

        // æ­¦å™¨å®šä¹‰
        const WEAPON_DEFS = [
            {
                key: 'gaoshu',
                name: 'é«˜æ•°å°„çº¿',
                color: '#4f8ef7',
                baseDamage: 2,
                baseFireRate: 16,
                type: 'line',
                desc: 'é«˜æ•°å°„çº¿ï¼Œç›´çº¿ç©¿é€ï¼ŒåŸºç¡€ä¼¤å®³',
            },
            {
                key: 'modian',
                name: 'æ¨¡ç”µæ•£å¼¹',
                color: '#f7b731',
                baseDamage: 1,
                baseFireRate: 18,
                type: 'spread',
                desc: 'æ¨¡ç”µæ•£å¼¹ï¼Œæ‰‡å½¢å¤šå‘ï¼Œè¦†ç›–é¢å¹¿',
            },
            {
                key: 'shudian',
                name: 'æ•°ç”µæ¿€å…‰',
                color: '#2ecc71',
                baseDamage: 1,
                baseFireRate: 40,
                type: 'laser',
                desc: 'æ•°ç”µæ¿€å…‰ï¼Œç›´çº¿æŒç»­é«˜ä¼¤å®³',
            },
            {
                key: 'xindai',
                name: 'çº¿ä»£æ°´æ³¢',
                color: '#00bcd4',
                baseDamage: 1,
                baseFireRate: 30,
                type: 'wave',
                desc: 'çº¿ä»£æ°´æ³¢ï¼Œæ¨ªå‘å¤§é¢ç§¯ä½ä¼¤å®³',
            },
            {
                key: 'tongyuan',
                name: 'é€šåŸçˆ†è£‚å¼¹',
                color: '#e17055',
                baseDamage: 1,
                baseFireRate: 22,
                type: 'explode',
                desc: 'é€šåŸçˆ†è£‚å¼¹ï¼Œå‘½ä¸­åˆ†è£‚å°å¼¹',
            },
            {
                key: 'dianbowave',
                name: 'ç”µç£æ³¢çŸ©é˜µ',
                color: '#ab47bc',
                baseDamage: 1,
                baseFireRate: 50,
                type: 'bigwave',
                desc: 'ç”µç£æ³¢çŸ©é˜µï¼Œå¤§èŒƒå›´ä½é¢‘æ”»å‡»',
            },
            {
                key: 'boomerang',
                name: 'å›æ—‹é•–',
                color: '#ffd600',
                baseDamage: 2,
                baseFireRate: 50,
                type: 'boomerang',
                desc: 'æŠ•æ·å›æ—‹é•–ï¼Œå¾€è¿”æ”»å‡»æ•Œäºº',
            },
            {
                key: 'chainlight',
                name: 'é—ªç”µé“¾',
                color: '#b388ff',
                baseDamage: 2,
                baseFireRate: 70,
                type: 'chainlight',
                desc: 'é—ªç”µå¼¹å°„å¤šåæ•Œäºº',
            },
        ];

        function getWeaponDef(key) {
            return WEAPON_DEFS.find(w => w.key === key);
        }

        // æ¸¸æˆæ•°æ®
        let player, bullets, enemies, enemyBullets, particles, upgrades, score, level, exp, expToLevel, wave, hp, gameState, upgradePool, lastUpgradeChoices, bossActive;

        function resetGame() {
            player = {
                x: W / 2 - 20, y: H - 80, w: 40, h: 40,
                speed: 5, // ç§»åŠ¨é€Ÿåº¦æå‡
                hp: 10,
                maxHp: 10,
                invincible: 0,
                shield: 0, // å¯å åŠ æŠ¤ç›¾æ•°é‡
                rapid: 0,  // è¿å°„å‰©ä½™å¸§æ•°
                dash: 0,   // å†²åˆºå‰©ä½™å¸§æ•°
                magnet: false,
                weapons: [
                    { key: 'gaoshu', name: 'é«˜æ•°å°„çº¿', level: 1, damage: 2, fireRate: 16, fireRateBonus: 0, fireTimer: 0, count: 1 },
                ],
                skills: [],
                magnetRange: 120, // å‡ºç”Ÿè‡ªå¸¦å¸é“çŸ³
            };
            bullets = [];
            enemies = [];
            enemyBullets = [];
            particles = [];
            upgrades = [];
            score = 0;
            level = 1;
            exp = 0;
            expToLevel = Math.floor(10 * Math.pow(1.4, level - 1));
            wave = 1;
            hp = 3;
            gameState = 'playing';
            bossActive = false;
            upgradePool = buildUpgradePool();
            lastUpgradeChoices = [];
        }

        // æŠ€èƒ½ä¸æ­¦å™¨å›¾æ ‡å®šä¹‰
        const ICONS = {
            gaoshu: 'ğŸ“',
            modian: 'ğŸ”‹',
            shudian: 'ğŸ’¡',
            xindai: 'ğŸ“',
            tongyuan: 'ğŸ“¡',
            dianbowave: 'ğŸŒŠ',
            magnet: 'ğŸ§²',
            maxhp: 'â¤ï¸',
            vamp: 'ğŸ©¸',
            crit: 'âš¡',
            rapid: 'ğŸ”«',
            shield: 'ğŸ›¡ï¸',
            expplus: 'ğŸ“š',
            heal: 'ğŸŒ±',
            cooldown: 'â±ï¸',
            boom: 'ğŸ’£',
            dash: 'ğŸƒ',
            boomerang: 'ğŸªƒ',
            chainlight: 'âš¡',
        };

        function buildUpgradePool() {
            let pool = [];
            for (const w of WEAPON_DEFS) {
                pool.push({
                    name: `è·å¾—${w.name}`,
                    desc: w.desc,
                    icon: ICONS[w.key] || 'âœ¨',
                    apply: p => {
                        if (!p.weapons.find(ww => ww.key === w.key)) {
                            p.weapons.push({ key: w.key, name: w.name, level: 1, damage: w.baseDamage, fireRate: w.baseFireRate, fireRateBonus: 0, fireTimer: 0, count: 1 });
                        }
                    },
                    onlyIf: p => !p.weapons.find(ww => ww.key === w.key)
                });
                pool.push({
                    name: `${w.name}ä¼¤å®³+1`,
                    desc: `${w.name}ä¼¤å®³æå‡`,
                    icon: ICONS[w.key],
                    apply: p => {
                        let weapon = p.weapons.find(ww => ww.key === w.key);
                        if (weapon) weapon.damage++;
                    },
                    onlyIf: p => !!p.weapons.find(ww => ww.key === w.key)
                });
                pool.push({
                    name: `${w.name}å°„é€Ÿ+10%`,
                    desc: `${w.name}å°„é€Ÿæå‡10%ï¼ˆå†·å´å‡å°‘ï¼‰`,
                    icon: ICONS[w.key],
                    apply: p => {
                        let weapon = p.weapons.find(ww => ww.key === w.key);
                        if (weapon) weapon.fireRateBonus = Math.min((weapon.fireRateBonus || 0) + 0.1, 0.7);
                    },
                    onlyIf: p => !!p.weapons.find(ww => ww.key === w.key)
                });
                pool.push({
                    name: `${w.name}å¼¹é“æ•°é‡+1`,
                    desc: `${w.name}æ¯æ¬¡å‘å°„å¼¹é“æ•°+1`,
                    icon: ICONS[w.key],
                    apply: p => {
                        let weapon = p.weapons.find(ww => ww.key === w.key);
                        if (weapon) weapon.count = (weapon.count || 1) + 1;
                    },
                    onlyIf: p => !!p.weapons.find(ww => ww.key === w.key) && (p.weapons.find(ww => ww.key === w.key).count || 1) < 6
                });
                // æ­¦å™¨å¸è¡€
                pool.push({
                    name: `${w.name}å¸æ”¶èƒ½é‡`,
                    desc: `ç”¨${w.name}å‡»ä¸­æ•Œäººæ—¶å›å¤1ä½“åŠ›ï¼ˆå†·å´1sï¼‰`,
                    icon: ICONS.vamp,
                    apply: p => {
                        let weapon = p.weapons.find(ww => ww.key === w.key);
                        if (weapon) weapon.vamp = true;
                    },
                    onlyIf: p => !!p.weapons.find(ww => ww.key === w.key) && !p.weapons.find(ww => ww.key === w.key).vamp
                });
            }
            pool.push({ name: 'å¸é“çŸ³', desc: 'è‡ªåŠ¨å¸å–ç»éªŒçƒï¼ŒèŒƒå›´æå‡', icon: ICONS.magnet, apply: p => { p.magnetRange = (p.magnetRange || 120) + 40; }, onlyIf: () => true });
            pool.push({ name: 'ä½“åŠ›ä¸Šé™+1', desc: 'æœ€å¤§ä½“åŠ›+1', icon: ICONS.maxhp, apply: p => { p.maxHp = (p.maxHp || 3) + 1; }, onlyIf: () => true });
            pool.push({ name: 'æš´å‡»', desc: 'æœ‰10%æ¦‚ç‡é€ æˆåŒå€ä¼¤å®³', icon: ICONS.crit, apply: p => { p.crit = true; }, onlyIf: p => !p.crit });
            pool.push({ name: 'è¿å°„', desc: 'çŸ­æ—¶é—´å†…æ‰€æœ‰æ­¦å™¨å°„é€Ÿç¿»å€', icon: ICONS.rapid, apply: p => { p.rapid = 300; }, onlyIf: p => !p.rapid });
            pool.push({ name: 'æŠ¤ç›¾', desc: 'è·å¾—ä¸€æ¬¡å¯æŠµæŒ¡ä¼¤å®³çš„æŠ¤ç›¾', icon: ICONS.shield, apply: p => { p.shield = true; }, onlyIf: p => !p.shield });
            pool.push({ name: 'ç»éªŒåŠ æˆ', desc: 'è·å¾—ç»éªŒæ—¶é¢å¤–+1', icon: ICONS.expplus, apply: p => p.skills.push('expPlus'), onlyIf: p => !p.skills.includes('expPlus') });
            pool.push({ name: 'å›è¡€å…‰ç¯', desc: 'æ¯20ç§’è‡ªåŠ¨å›å¤1ä½“åŠ›', icon: ICONS.heal, apply: p => { p.healAura = true; }, onlyIf: p => !p.healAura });
            pool.push({ name: 'å†·å´ç¼©çŸ­', desc: 'æ‰€æœ‰æ­¦å™¨å°„é€Ÿæ°¸ä¹…æå‡', icon: ICONS.cooldown, apply: p => { for (let w of p.weapons) w.fireRate = Math.max(3, w.fireRate - 2); }, onlyIf: () => true });
            pool.push({ name: 'èŒƒå›´çˆ†ç‚¸', desc: 'å‡»æ€æ•Œäººæ—¶é€ æˆå°èŒƒå›´æº…å°„ä¼¤å®³', icon: ICONS.boom, apply: p => { p.boom = true; }, onlyIf: p => !p.boom });
            pool.push({ name: 'æ— æ•Œå†²åˆº', desc: 'çŸ­æ—¶é—´å†…æ— æ•Œå¹¶æå‡ç§»åŠ¨é€Ÿåº¦', icon: ICONS.dash, apply: p => { p.dash = 180; }, onlyIf: p => !p.dash });
            return pool;
        }

        function randomUpgradeChoices(n = 3) {
            let pool = upgradePool.filter(u => u.onlyIf(player) && !lastUpgradeChoices.includes(u));
            if (pool.length < n) pool = upgradePool.filter(u => u.onlyIf(player));
            let arr = [];
            while (arr.length < n) {
                let idx = Math.floor(Math.random() * pool.length);
                if (!arr.includes(pool[idx])) arr.push(pool[idx]);
            }
            lastUpgradeChoices = arr;
            return arr;
        }

        function showUpgradePanel() {
            upgradePanel.style.display = 'block';
            upgradeOptionsDiv.innerHTML = '';
            let choices = randomUpgradeChoices();
            choices.forEach(upg => {
                let div = document.createElement('div');
                div.className = 'upgrade-option';
                div.innerHTML = `<span style="font-size:28px;vertical-align:middle;margin-right:10px;">${upg.icon || 'âœ¨'}</span><b>${upg.name}</b><br><small>${upg.desc}</small>`;
                div.onclick = () => {
                    upg.apply(player);
                    if (player.skills.includes('extraExpOnLevel')) exp++;
                    upgradePanel.style.display = 'none';
                    gameState = 'playing';
                    lastFrameTime = performance.now();
                    requestAnimationFrame(gameLoop);
                };
                upgradeOptionsDiv.appendChild(div);
            });
            gameState = 'upgrade';
        }

        function showGameOver() {
            gameOverDiv.style.display = 'block';
            const gradeTitle = level <= 5 ? 'å¤§ä¸€èŒæ–°'
                : level <= 10 ? 'å¤§äºŒå­¦éœ¸'
                    : level <= 15 ? 'å¤§ä¸‰å·ç‹'
                        : level <= 20 ? 'å¤§å››å­¦ç¥'
                            : level <= 25 ? 'ç ”ä¸€ç§‘ç ”ç‹—'
                                : 'åšå¯¼ï¼';
            finalScoreDiv.innerHTML = `
              <div style="font-size:1.4em;margin-bottom:6px">å¹´çº§ï¼š${level}</div>
              <div style="color:#e57373;font-size:1.2em">ã€${gradeTitle}ã€‘</div>
              <div style="font-size:1em;margin-top:4px">ç»©ç‚¹ï¼š${score}</div>
              ${score >= 10000 ? '<button onclick="revive()" style="margin-top:12px;padding:8px 20px;background:#ff7043;color:#fff;border:none;border-radius:6px;">èŠ±1ä¸‡ç»©ç‚¹è®©è€å¸ˆææˆ‘ï¼</button>' : ''}
            `;
            gameState = 'over';
        }

        let preGameBuffCount = 0;
        const startPanel = document.getElementById('start-panel');
        const btnYes = document.getElementById('btn-yes');
        const btnNo = document.getElementById('btn-no');
        const btnStart = document.getElementById('btn-start');
        const answerTip = document.getElementById('answer-tip');

        btnYes.onclick = function () {
            answerTip.textContent = 'ç­”å¯¹äº†ï¼å¼€å±€èµ é€ä¸‰æ¬¡å¢ç›Šé€‰æ‹©';
            preGameBuffCount = 3;
            btnStart.disabled = false;
        };
        btnNo.onclick = function () {
            answerTip.textContent = 'ç­”é”™äº†ï¼Œæ­£å¸¸å¼€å§‹æ¸¸æˆ';
            preGameBuffCount = 0;
            btnStart.disabled = false;
        };
        btnStart.onclick = function () {
            startPanel.style.display = 'none';
            resetGame();
            if (preGameBuffCount > 0) {
                showPreGameBuffs(preGameBuffCount);
            } else {
                requestAnimationFrame(gameLoop);
            }
        };

        function showPreGameBuffs(n) {
            if (n <= 0) {
                upgradePanel.style.display = 'none';
                gameState = 'playing';
                requestAnimationFrame(gameLoop);
                return;
            }
            upgradePanel.style.display = 'block';
            upgradeOptionsDiv.innerHTML = '';
            let choices = randomUpgradeChoices();
            choices.forEach(upg => {
                let div = document.createElement('div');
                div.className = 'upgrade-option';
                div.innerHTML = `<span style="font-size:28px;vertical-align:middle;margin-right:10px;">${upg.icon || 'âœ¨'}</span><b>${upg.name}</b><br><small>${upg.desc}</small>`;
                div.onclick = () => {
                    upg.apply(player);
                    if (player.skills.includes('extraExpOnLevel')) exp++;
                    upgradePanel.style.display = 'none';
                    showPreGameBuffs(n - 1);
                };
                upgradeOptionsDiv.appendChild(div);
            });
            gameState = 'upgrade';
        }

        // æ¸¸æˆç»“æŸ/é‡å¼€æ—¶é‡ç½®ç­”é¢˜é¢æ¿
        function restartGame() {
            gameOverDiv.style.display = 'none';
            startPanel.style.display = 'flex';
            btnStart.disabled = true;
            answerTip.textContent = '';
            preGameBuffCount = 0;
        }

        // é¡µé¢åŠ è½½æ—¶åªæ˜¾ç¤ºå¼€å§‹é¢æ¿
        window.addEventListener('DOMContentLoaded', function () {
            startPanel.style.display = 'flex';
            btnStart.disabled = true;
            answerTip.textContent = '';
            preGameBuffCount = 0;
        });

        // æ§åˆ¶
        let keys = {};
        document.addEventListener('keydown', e => { keys[e.key] = true; });
        document.addEventListener('keyup', e => { keys[e.key] = false; });

        // ç»éªŒçƒ
        let exps = [];
        function spawnExp(x, y, amount = 1) {
            for (let i = 0; i < amount; i++) {
                exps.push({ x: x + Math.random() * 20 - 10, y: y + Math.random() * 20 - 10, r: 6, v: 1 + Math.random() * 1.5, angle: Math.random() * Math.PI * 2 });
            }
        }

        function updateExp() {
            for (let i = exps.length - 1; i >= 0; i--) {
                let e = exps[i];
                // å¸é“çŸ³å¸é™„é€»è¾‘
                if (player.magnetRange) {
                    const px = player.x + player.w / 2, py = player.y + player.h / 2;
                    const dx = px - e.x, dy = py - e.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < player.magnetRange) {
                        const speed = 6;
                        e.x += dx / dist * speed;
                        e.y += dy / dist * speed;
                    } else {
                        e.y += e.v;
                    }
                } else {
                    e.y += e.v;
                }
                if (Math.abs(e.x + e.r / 2 - player.x - player.w / 2) < player.w / 2 && Math.abs(e.y + e.r / 2 - player.y - player.h / 2) < player.h / 2) {
                    let add = 1;
                    if (player.skills.includes('expPlus')) add++;
                    exp += add;
                    exps.splice(i, 1);
                    if (exp >= expToLevel) {
                        exp -= expToLevel;
                        level++;
                        expToLevel = Math.floor(10 * Math.pow(1.4, level - 1));
                        showUpgradePanel();
                    }
                } else if (e.y > H + 20) {
                    exps.splice(i, 1);
                }
            }
        }

        // æ•Œäººç”Ÿæˆ
        function spawnEnemy() {
            let t = wave;
            let type = 'normal';
            let hp = 5 + t * 2 + Math.floor(Math.random() * t); // è¡€é‡æˆé•¿æ›´å¿«
            let speed = 1.2;
            let color = '#f44';
            if (t > 3 && Math.random() < 0.2) { type = 'quiz'; speed = 2.4; color = '#ff0'; }
            if (t > 5 && Math.random() < 0.15) { type = 'exam'; hp += 5; color = '#0af'; }
            if (t > 7 && Math.random() < 0.1) { type = 'paper'; color = '#fff'; }
            if (t > 10 && Math.random() < 0.08) { type = 'boss'; hp += 10; speed = 1.9; color = '#0f0'; }
            let x = Math.random() * (W - 40);
            enemies.push({ x, y: -40, w: 40, h: 40, hp, maxHp: hp, speed, type, color });
        }

        function spawnBoss() {
            bossActive = true;
            let hp = 60 + wave * 15;
            enemies.push({ x: W / 2 - 60, y: -120, w: 120, h: 120, hp, maxHp: hp, speed: 1.1, type: 'boss', color: '#f0f' }); // å›ºå®šBossé€Ÿåº¦
        }

        // å¤šæ­¦å™¨è‡ªåŠ¨å°„å‡»
        function fireWeapons(delta) {
            for (const w of player.weapons) {
                w.fireTimer -= delta;
                if (w.fireTimer <= 0) {
                    let def = getWeaponDef(w.key);
                    let count = w.count || 1;
                    if (def.type === 'line') {
                        for (let c = 0; c < count; c++) {
                            let offset = (c - (count - 1) / 2) * 18;
                            bullets.push({ x: player.x + player.w / 2 - 6 + offset, y: player.y - 12, w: 12, h: 24, dx: 0, dy: -8 - w.level, damage: w.damage, color: def.color, effect: 'line', level: w.level, life: 0, owner: w.key, vamp: w.vamp });
                        }
                    } else if (def.type === 'spread') {
                        let spread = 30 + 5 * w.level;
                        let cnt = (3 + Math.floor(w.level / 2)) * count;
                        for (let i = 0; i < cnt; i++) {
                            let angle = (-(cnt - 1) / 2 + i) * spread * Math.PI / 180;
                            let dx = Math.sin(angle) * 7, dy = -Math.cos(angle) * 7;
                            bullets.push({ x: player.x + player.w / 2 - 6, y: player.y - 12, w: 12, h: 24, dx, dy, damage: w.damage, color: def.color, effect: 'spread', level: w.level, life: 0, owner: w.key, vamp: w.vamp });
                        }
                    } else if (def.type === 'laser') {
                        for (let c = 0; c < count; c++) {
                            let offset = (c - (count - 1) / 2) * 18;
                            bullets.push({ x: player.x + player.w / 2 - 3 + offset, y: 0, w: 6, h: player.y + player.h / 2, dx: 0, dy: 0, damage: w.damage, color: def.color, effect: 'laser', level: w.level, life: 0, owner: w.key, duration: 20 + 5 * w.level, laserEndY: 0, vamp: w.vamp });
                        }
                    } else if (def.type === 'wave' || def.type === 'bigwave') {
                        for (let c = 0; c < count; c++) {
                            let offset = (c - (count - 1) / 2) * 18;
                            bullets.push({ x: player.x + player.w / 2 - 10 + offset, y: player.y + player.h / 2 - 10, w: 20, h: 20, dx: 0, dy: 0, damage: w.damage, color: def.color, effect: def.type, level: w.level, life: 0, owner: w.key, r: 0, _hitList: [], penetrate: w.penetrate || (def.type === 'wave' ? 1 : 999), vamp: w.vamp });
                        }
                    } else if (def.type === 'explode') {
                        for (let c = 0; c < count; c++) {
                            let offset = (c - (count - 1) / 2) * 18;
                            bullets.push({ x: player.x + player.w / 2 - 8 + offset, y: player.y - 12, w: 16, h: 16, dx: 0, dy: -7 - w.level, damage: w.damage, color: def.color, effect: 'explode', level: w.level, life: 0, owner: w.key, vamp: w.vamp });
                        }
                    } else if (def.type === 'boomerang') {
                        for (let c = 0; c < count; c++) {
                            let angle = Math.random() * Math.PI * 2 + (c * 2 * Math.PI / count);
                            bullets.push({
                                angle: angle,
                                radius: 60 + 10 * w.level,
                                w: 24, h: 24,
                                damage: w.damage,
                                color: def.color,
                                effect: 'boomerang',
                                level: w.level,
                                life: 0,
                                owner: w.key,
                                spinSpeed: 0.08 + 0.02 * w.level,
                                duration: 9999
                            });
                        }
                    } else if (def.type === 'chainlight') {
                        for (let c = 0; c < count; c++) {
                            let startX = player.x + player.w / 2, startY = player.y;
                            let chainTargets = [];
                            let lastX = startX, lastY = startY;
                            let remain = 4 + w.level;
                            let hitSet = new Set();
                            while (remain-- > 0) {
                                let minDist = 9999, minIdx = -1;
                                for (let i = 0; i < enemies.length; i++) {
                                    if (hitSet.has(i)) continue;
                                    let e = enemies[i];
                                    let dx = e.x + e.w / 2 - lastX, dy = e.y + e.h / 2 - lastY;
                                    let dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist < minDist && dist < 220) {
                                        minDist = dist;
                                        minIdx = i;
                                    }
                                }
                                if (minIdx >= 0) {
                                    let e = enemies[minIdx];
                                    chainTargets.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, idx: minIdx });
                                    hitSet.add(minIdx);
                                    lastX = e.x + e.w / 2;
                                    lastY = e.y + e.h / 2;
                                } else {
                                    break;
                                }
                            }
                            if (chainTargets.length > 0) {
                                bullets.push({
                                    x: startX, y: startY,
                                    chain: chainTargets,
                                    damage: w.damage,
                                    color: def.color,
                                    effect: 'chainlight',
                                    level: w.level,
                                    life: 0,
                                    owner: w.key
                                });
                            }
                        }
                    }
                    let bonus = (w.fireRateBonus || 0);
                    let rapidMult = player.rapid > 0 ? 2 : 1;
                    w.fireTimer = Math.max(1, w.fireRate / (1 + bonus) / rapidMult);
                }
            }
        }

        // æ–°å¢ï¼šåº•éƒ¨ä¹¦æœ¬å †å åŸå¢™
        function drawBooksWall(flash = false) {
            const wallH = 36, bookW = 40, bookH = 28;
            let y = H - wallH;
            for (let i = 0; i < Math.ceil(W / bookW); i++) {
                let x = i * bookW;
                ctx.save();
                ctx.globalAlpha = flash ? 0.5 + 0.5 * Math.sin(Date.now() / 60) : 1;
                ctx.fillStyle = i % 2 === 0 ? '#b388ff' : '#ffe082';
                ctx.fillRect(x, y, bookW - 4, bookH);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, bookW - 4, bookH);
                ctx.fillStyle = '#fff';
                ctx.fillRect(x + 6, y + 6, bookW - 16, bookH - 16);
                ctx.restore();
            }
        }

        // æ¸¸æˆä¸»å¾ªç¯
        document.addEventListener('visibilitychange', () => { if (document.hidden && gameState === 'playing') gameState = 'pause'; });
        function gameLoop(now) {
            if (gameState === 'over') return;
            if (gameState === 'pause') { requestAnimationFrame(gameLoop); return; }
            if (gameState === 'upgrade') return;
            let delta = (now - lastFrameTime) / 16.67;
            lastFrameTime = now;
            // èƒŒæ™¯
            ctx.fillStyle = '#e3eafc';
            ctx.fillRect(0, 0, W, H);
            // æ–°å¢ï¼šåŠ¨æ€èƒŒæ™¯äº‘å±‚
            for (let i = 0; i < 6; i++) {
                let cloudX = (now / 30 + i * 80) % (W + 100) - 100;
                let cloudY = 60 + i * 60 + Math.sin(now / 600 + i) * 10;
                ctx.save();
                ctx.globalAlpha = 0.12 + 0.08 * Math.sin(now / 400 + i);
                ctx.beginPath();
                ctx.ellipse(cloudX, cloudY, 70, 28, 0, 0, 2 * Math.PI);
                ctx.fillStyle = '#fff';
                ctx.fill();
                ctx.restore();
            }
            for (let i = 0; i < 30; i++) {
                ctx.fillStyle = 'rgba(76,142,247,0.08)';
                ctx.beginPath(); ctx.arc(Math.random() * W, Math.random() * H, Math.random() * 2 + 1, 0, 2 * Math.PI); ctx.fill();
            }
            // åº•éƒ¨ä¹¦æœ¬åŸå¢™
            drawBooksWall(hpFlashTimer > 0);
            // ç«ç„°/å†°éœœåœ°å¸¦æå‰ç»˜åˆ¶ï¼Œç¡®ä¿åœ¨æ•Œäººå’Œå­å¼¹ä¸‹æ–¹
            for (let i = 0; i < bullets.length; i++) {
                let b = bullets[i];
                if (b.effect === 'flamezone' || b.effect === 'frostzone') {
                    ctx.save();
                    ctx.globalAlpha = 0.5 + 0.2 * Math.sin(Date.now() / 80);
                    let grad = ctx.createRadialGradient(b.x + b.w / 2, b.y + b.h / 2, 8, b.x + b.w / 2, b.y + b.h / 2, b.w / 2);
                    if (b.effect === 'flamezone') {
                        grad.addColorStop(0, '#fff3e0');
                        grad.addColorStop(0.4, '#ff7043');
                        grad.addColorStop(1, 'rgba(255,112,67,0)');
                    } else {
                        grad.addColorStop(0, '#e3f2fd');
                        grad.addColorStop(0.4, '#81d4fa');
                        grad.addColorStop(1, 'rgba(129,212,250,0)');
                    }
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.ellipse(b.x + b.w / 2, b.y + b.h / 2, b.w / 2, b.h / 2, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.restore();
                }
            }
            // æ³¢ç±»å‹æ”»å‡»ï¼ˆåœ¨æœ€åº•å±‚ï¼‰
            for (let b of bullets) {
                if (b.effect === 'wave' || b.effect === 'bigwave') {
                    ctx.save();
                    ctx.strokeStyle = b.color;
                    ctx.lineWidth = b.effect === 'wave' ? 6 : 12;
                    ctx.globalAlpha = 0.4;
                    // å˜å¤§çš„ç©ºå¿ƒåœ†ç¯
                    let cx = b.x + b.w / 2, cy = b.y + b.h / 2;
                    let r = b.r || (b.effect === 'wave' ? W / 2 - 10 : W / 2 - 2);
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.restore();
                }
            }
            // ç©å®¶
            ctx.save();
            ctx.beginPath(); ctx.arc(player.x + player.w / 2, player.y + player.h / 2, player.w / 2, 0, 2 * Math.PI); ctx.fillStyle = '#fff'; ctx.fill();
            ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 2; ctx.stroke();
            ctx.fillStyle = '#2c3e50'; ctx.fillRect(player.x + player.w / 2 - 14, player.y + player.h / 2 - 28, 28, 8);
            ctx.beginPath(); ctx.moveTo(player.x + player.w / 2, player.y + player.h / 2 - 20); ctx.lineTo(player.x + player.w / 2, player.y + player.h / 2 - 10); ctx.stroke();
            ctx.restore();
            // ç©å®¶è¡€æ¡ï¼ˆæ”¯æŒå°æ•°ï¼‰
            ctx.save();
            let barW = player.w, barH = 8;
            let px = player.x, py = player.y + player.h + 6;
            ctx.fillStyle = '#ddd';
            ctx.fillRect(px, py, barW, barH);
            ctx.fillStyle = '#4caf50';
            ctx.fillRect(px, py, barW * (player.hp / player.maxHp), barH);
            ctx.strokeStyle = '#222'; ctx.strokeRect(px, py, barW, barH);
            ctx.font = '10px Arial';
            ctx.fillStyle = '#222';
            ctx.fillText(`${player.hp.toFixed(1)}/${player.maxHp}`, px + 2, py + barH - 1);
            ctx.restore();
            // ç©å®¶æ— æ•Œé—ªçƒ
            if (player.invincible > 0) {
                ctx.globalAlpha = 0.5 + 0.5 * Math.sin(Date.now() / 80);
                ctx.fillStyle = '#2ecc71';
                ctx.beginPath(); ctx.arc(player.x + player.w / 2, player.y + player.h / 2, player.w / 2 + 4, 0, 2 * Math.PI); ctx.fill();
                ctx.globalAlpha = 1;
                player.invincible--;
            }
            // æŠ¤ç›¾UIæç¤º
            if (player.shield > 0) {
                ctx.save();
                ctx.globalAlpha = 0.5 + 0.5 * Math.sin(Date.now() / 120);
                ctx.strokeStyle = '#00bcd4';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(player.x + player.w / 2, player.y + player.h / 2, player.w / 2 + 8, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.restore();
            }
            // ç©å®¶ç§»åŠ¨
            if (gameState === 'playing') {
                let move = player.speed * delta;
                if (keys['ArrowLeft'] || keys['a']) player.x = Math.max(0, player.x - move);
                if (keys['ArrowRight'] || keys['d']) player.x = Math.min(W - player.w, player.x + move);
                if (keys['ArrowUp'] || keys['w']) player.y = Math.max(0, player.y - move);
                if (keys['ArrowDown'] || keys['s']) player.y = Math.min(H - player.h, player.y + move);
            }
            // å¤šæ­¦å™¨è‡ªåŠ¨å°„å‡»
            fireWeapons(delta);
            // å­å¼¹
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                // æ³¢ç±»å­å¼¹å˜å¤§
                if (b.effect === 'wave' || b.effect === 'bigwave') {
                    b.r = (b.r || 0) + (b.effect === 'wave' ? 8 : 5) * delta;
                    if (!b._hitList) b._hitList = [];
                    if (b.penetrate === undefined) b.penetrate = b.effect === 'wave' ? 1 : 999;
                }
                b.x += b.dx * delta;
                b.y += b.dy * delta;
                b.life++;
                // ä¼šè®¡æ¿€å…‰æ˜¾ç¤ºä¼˜åŒ–
                if (b.effect === 'laser') {
                    ctx.save();
                    ctx.globalAlpha = 0.7;
                    ctx.shadowColor = '#39ff14';
                    ctx.shadowBlur = 24;
                    ctx.strokeStyle = '#39ff14';
                    ctx.lineWidth = 18;
                    ctx.beginPath();
                    ctx.moveTo(b.x + b.w / 2, player.y + player.h / 2);
                    ctx.lineTo(b.x + b.w / 2, 0);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    ctx.restore();
                }
                // æ–°å¢ï¼šç«ç„°/å†°éœœåœ°å¸¦
                if (b.effect === 'flamezone' || b.effect === 'frostzone') {
                    ctx.save();
                    ctx.globalAlpha = 0.5 + 0.2 * Math.sin(Date.now() / 80);
                    let grad = ctx.createRadialGradient(b.x + b.w / 2, b.y + b.h / 2, 8, b.x + b.w / 2, b.y + b.h / 2, b.w / 2);
                    if (b.effect === 'flamezone') {
                        grad.addColorStop(0, '#fff3e0');
                        grad.addColorStop(0.4, '#ff7043');
                        grad.addColorStop(1, 'rgba(255,112,67,0)');
                    } else {
                        grad.addColorStop(0, '#e3f2fd');
                        grad.addColorStop(0.4, '#81d4fa');
                        grad.addColorStop(1, 'rgba(129,212,250,0)');
                    }
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.ellipse(b.x + b.w / 2, b.y + b.h / 2, b.w / 2, b.h / 2, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.restore();
                }
                // æ–°å¢ï¼šå›æ—‹é•–
                if (b.effect === 'boomerang') {
                    ctx.save();
                    ctx.translate(b.x + b.w / 2, b.y + b.h / 2);
                    ctx.rotate(b.life / 6);
                    ctx.fillStyle = b.color;
                    ctx.beginPath();
                    ctx.moveTo(-10, 0);
                    ctx.lineTo(0, -10);
                    ctx.lineTo(10, 0);
                    ctx.lineTo(0, 10);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
                // æ–°å¢ï¼šé—ªç”µé“¾
                if (b.effect === 'chainlight' && b.chain) {
                    ctx.save();
                    // ä¸»é—ªç”µçº¿ï¼šæ›´äº®æ›´ç²—
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 16;
                    ctx.shadowColor = '#fff';
                    ctx.shadowBlur = 48;
                    ctx.beginPath();
                    ctx.moveTo(b.x, b.y);
                    for (let t of b.chain) {
                        let offx = t.x + (Math.random() - 0.5) * 16, offy = t.y + (Math.random() - 0.5) * 16;
                        ctx.lineTo(offx, offy);
                    }
                    ctx.stroke();
                    // å¤–è½®å»“ï¼šæ·±ç´«è‰²æ›´ç²—
                    ctx.strokeStyle = '#6c00ff';
                    ctx.lineWidth = 8;
                    ctx.shadowColor = '#6c00ff';
                    ctx.shadowBlur = 32;
                    ctx.beginPath();
                    ctx.moveTo(b.x, b.y);
                    for (let t of b.chain) {
                        let offx = t.x + (Math.random() - 0.5) * 16, offy = t.y + (Math.random() - 0.5) * 16;
                        ctx.lineTo(offx, offy);
                    }
                    ctx.stroke();
                    // åˆ†å‰æ›´å¤š
                    for (let k = 1; k < b.chain.length; k++) {
                        for (let f = 0; f < 2; f++) {
                            if (Math.random() < 0.7) {
                                ctx.strokeStyle = '#fff';
                                ctx.lineWidth = 3;
                                ctx.shadowColor = '#fff';
                                ctx.shadowBlur = 12;
                                ctx.beginPath();
                                ctx.moveTo(b.chain[k - 1].x, b.chain[k - 1].y);
                                let angle = Math.atan2(b.chain[k].y - b.chain[k - 1].y, b.chain[k].x - b.chain[k - 1].x) + (Math.random() - 0.5) * 1.5;
                                let len = 40 + Math.random() * 30;
                                ctx.lineTo(b.chain[k - 1].x + Math.cos(angle) * len, b.chain[k - 1].y + Math.sin(angle) * len);
                                ctx.stroke();
                            }
                        }
                    }
                    // æœ«ç«¯ç²’å­æ›´å¤§æ›´äº®
                    for (let t of b.chain) {
                        ctx.save();
                        ctx.globalAlpha = 0.85;
                        ctx.beginPath();
                        ctx.arc(t.x, t.y, 16 + Math.random() * 6, 0, 2 * Math.PI);
                        ctx.fillStyle = '#fff';
                        ctx.shadowColor = '#6c00ff';
                        ctx.shadowBlur = 32;
                        ctx.fill();
                        ctx.restore();
                    }
                    ctx.restore();
                }
                // ç»˜åˆ¶ï¼ˆéæ³¢ç±»ã€éæ¿€å…‰ï¼‰
                if (b.effect !== 'wave' && b.effect !== 'bigwave' && b.effect !== 'laser') {
                    ctx.save(); ctx.shadowColor = b.color; ctx.shadowBlur = 8; ctx.fillStyle = b.color;
                    ctx.beginPath(); ctx.arc(b.x + b.w / 2, b.y + b.h / 2, b.w / 2, 0, 2 * Math.PI); ctx.fill(); ctx.restore();
                }
                // å­å¼¹æ•ˆæœ
                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    let e = enemies[j];
                    if (!e) continue;
                    // æ³¢ç±»åˆ¤å®š
                    if ((b.effect === 'wave' || b.effect === 'bigwave')) {
                        let cx = b.x + b.w / 2, cy = b.y + b.h / 2, r = b.r || 0;
                        let ex = e.x + e.w / 2, ey = e.y + e.h / 2;
                        let dist = Math.abs(Math.hypot(cx - ex, cy - ey) - r);
                        if (dist < e.w / 2 + 6 && !b._hitList.includes(j)) {
                            e.hp -= b.damage;
                            e.hitFlash = 3;
                            b._hitList.push(j);
                            showDamage(ex, ey, Math.round(b.damage));
                            if (b.effect === 'wave') {
                                b.penetrate--;
                                if (b.penetrate <= 0) { hit = true; break; }
                            }
                        }
                    } else if (b.x + b.w > e.x && b.x < e.x + e.w && b.y + b.h > e.y && b.y < e.y + e.h) {
                        hit = true;
                        // å¸è¡€åˆ¤å®š
                        if (b.vamp && vampCooldown <= 0 && player.hp < player.maxHp) {
                            player.hp = Math.min(player.maxHp, player.hp + 0.1);
                            vampCooldown = 60;
                        }
                        e.hp -= b.damage;
                        e.hitFlash = 3;
                        showDamage(e.x + e.w / 2, e.y, Math.round(b.damage));
                        if (b.effect === 'explode') {
                            for (let k = 0; k < 3; k++) {
                                let angle = Math.random() * Math.PI * 2;
                                let dx = Math.cos(angle) * 4, dy = Math.sin(angle) * 4;
                                bullets.push({ x: e.x + e.w / 2 - 4, y: e.y + e.h / 2 - 4, w: 8, h: 8, dx, dy, damage: Math.max(1, Math.floor(b.damage / 2)), color: '#b2bec3', effect: 'mini', level: 1, life: 0, pierce: 0, owner: 'mini' });
                            }
                        }
                        break;
                    }
                }
                // ç«ç„°/å†°éœœåœ°å¸¦åˆ¤å®š
                if (b.effect === 'flamezone' || b.effect === 'frostzone') {
                    const DAMAGE_INTERVAL = 60; // 1ç§’ä¸€æ¬¡
                    b.damageTimer = (b.damageTimer || 0) + 1;
                    if (b.damageTimer % DAMAGE_INTERVAL === 0) {
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            let e = enemies[j];
                            let ex = e.x + e.w / 2, ey = e.y + e.h / 2;
                            if (ex > b.x && ex < b.x + b.w && ey > b.y && ey < b.y + b.h) {
                                e.hp -= b.damage * (b.effect === 'flamezone' ? 0.6 : 0.3);
                                e.hitFlash = 2;
                            }
                        }
                    }
                    b.duration--;
                    if (b.duration <= 0) bullets.splice(i, 1);
                    continue; // å…³é”®ï¼šè·³è¿‡åç»­é€»è¾‘ï¼Œé˜²æ­¢å¤šæ¬¡åˆ¤å®š
                }
                // å›æ—‹é•–è¿åŠ¨
                if (b.effect === 'boomerang') {
                    // å›´ç»•ç©å®¶æ—‹è½¬ï¼Œè§†è§‰å¢å¼º
                    b.angle += b.spinSpeed * 1.5 * delta;
                    let px = player.x + player.w / 2, py = player.y + player.h / 2;
                    let bx = px + Math.cos(b.angle) * b.radius, by = py + Math.sin(b.angle) * b.radius;
                    // æ®‹å½±
                    for (let t = 1; t <= 4; t++) {
                        let fade = 0.18 * (5 - t);
                        let ax = px + Math.cos(b.angle - t * 0.25) * b.radius;
                        let ay = py + Math.sin(b.angle - t * 0.25) * b.radius;
                        ctx.save();
                        ctx.globalAlpha = fade;
                        ctx.beginPath();
                        ctx.arc(ax, ay, b.w / 2 + 2, 0, 2 * Math.PI);
                        ctx.fillStyle = '#fffde7';
                        ctx.fill();
                        ctx.restore();
                    }
                    // ä¸»ä½“
                    ctx.save();
                    ctx.translate(bx, by);
                    ctx.rotate(b.angle);
                    ctx.beginPath();
                    ctx.arc(0, 0, b.w / 2 + 2, 0, 2 * Math.PI);
                    ctx.fillStyle = '#fffde7';
                    ctx.fill();
                    ctx.lineWidth = 4;
                    ctx.strokeStyle = '#ffd600';
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-8, 0);
                    ctx.lineTo(0, -12);
                    ctx.lineTo(8, 0);
                    ctx.lineTo(0, 12);
                    ctx.closePath();
                    ctx.fillStyle = b.color;
                    ctx.shadowColor = '#ffd600';
                    ctx.shadowBlur = 16;
                    ctx.fill();
                    ctx.restore();
                    b.x = bx - b.w / 2;
                    b.y = by - b.h / 2;
                    // å‡»ä¸­æ•Œäººæ—¶ç²’å­ç‰¹æ•ˆ
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        let e = enemies[j];
                        let ex = e.x + e.w / 2, ey = e.y + e.h / 2;
                        let dist = Math.hypot(ex - bx, ey - by);
                        if (dist < b.w / 2 + e.w / 2) {
                            e.hp -= b.damage * 0.5;
                            for (let p = 0; p < 2; p++) {
                                let angle = Math.random() * Math.PI * 2;
                                let speed = 1 + Math.random() * 1.5;
                                particles.push({
                                    x: bx,
                                    y: by,
                                    dx: Math.cos(angle) * speed,
                                    dy: Math.sin(angle) * speed,
                                    r: 2 + Math.random() * 1.5,
                                    color: '#ffd600',
                                    life: 10 + Math.random() * 6,
                                    maxLife: 10 + Math.random() * 6
                                });
                            }
                        }
                    }
                }
                // é—ªç”µé“¾åˆ¤å®š
                if (b.effect === 'chainlight' && b.chain) {
                    for (let k = 0; k < b.chain.length; k++) {
                        let t = b.chain[k];
                        let e = enemies[t.idx];
                        if (e) {
                            e.hp -= b.damage;
                            e.hitFlash = 3;
                            showDamage(e.x + e.w / 2, e.y, Math.round(b.damage));
                        }
                    }
                    b.life = (b.life || 0) + 1;
                    if (b.life > 10) { // 10å¸§åå†ç§»é™¤
                        bullets.splice(i, 1);
                        continue;
                    }
                }
                if (b.effect === 'laser') {
                    // æ¿€å…‰æŒç»­æ—¶é—´
                    b.duration--;
                    // æ–°å¢ï¼šæ¿€å…‰å‡»ä¸­åä¹Ÿä¿æŒç»˜åˆ¶ä¸€æ®µæ—¶é—´
                    b.life = (b.life || 0) + 1;
                    if (b.duration <= 0 && b.life > 10) hit = true;
                }
                if (b.effect === 'wave') {
                    // æ°´æ³¢æ¶ˆå¤±æ¡ä»¶ï¼šå‡»ä¸­æ•Œäººæˆ–è¶…å¤§
                    if ((b.penetrate !== undefined && b.penetrate <= 0) || b.r > Math.max(W, H)) hit = true;
                }
                if (b.effect === 'bigwave') {
                    // ç»æµæ³¢æ¶ˆå¤±æ¡ä»¶ï¼šæœ€å¤§åŠå¾„
                    if (b.r > W * 0.7) hit = true;
                }
                if (b.y < -30 || b.x < -30 || b.x > W + 30 || hit || b.life > 120) bullets.splice(i, 1);
            }
            if (vampCooldown > 0) vampCooldown--;
            // æ•Œäºº
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                if (!e) continue;
                // æ•Œäººç§»åŠ¨é€Ÿåº¦æ•´ä½“å‡ç¼“ï¼Œè®¾ç½®ä¸Šé™
                e.speed = Math.min(e.speed, 4.5); // é€Ÿåº¦ä¸Šé™
                e.y += e.speed * delta * 0.7;
                if (e.type === 'boss' && Math.random() < 0.03 * delta) {
                    let bx = e.x + e.w / 2 - 8, by = e.y + e.h - 10;
                    for (let k = -2; k <= 2; k++) {
                        enemyBullets.push({ x: bx, y: by, w: 8, h: 16, dx: k * 2, dy: 3, damage: 1 });
                    }
                }
                if (e.type === 'paper' && e.hp <= e.maxHp / 2 && !e.split) {
                    e.split = 1;
                    for (let k = 0; k < 2; k++) {
                        enemies.push({ x: e.x + Math.random() * 20 - 10, y: e.y + Math.random() * 20 - 10, w: 28, h: 28, hp: Math.floor(e.maxHp / 2), maxHp: Math.floor(e.maxHp / 2), speed: e.speed + 0.5, type: 'normal', color: '#fff' });
                    }
                }
                // æ•Œäººç»˜åˆ¶
                ctx.save();
                if (e.type === 'quiz') {
                    ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.arc(e.x + e.w / 2, e.y + e.h / 2, e.w / 2, 0, 2 * Math.PI); ctx.fill();
                    ctx.fillStyle = '#222'; ctx.font = 'bold 22px Arial'; ctx.fillText('?', e.x + e.w / 2 - 7, e.y + e.h / 2 + 8);
                } else if (e.type === 'exam') {
                    ctx.fillStyle = '#2196f3'; ctx.fillRect(e.x + 6, e.y + 10, e.w - 12, e.h - 20);
                    ctx.fillStyle = '#fff'; ctx.fillRect(e.x + 10, e.y + 14, e.w - 20, e.h - 28);
                } else if (e.type === 'paper') {
                    ctx.fillStyle = '#fff'; ctx.fillRect(e.x + 8, e.y + 8, e.w - 16, e.h - 16);
                    ctx.strokeStyle = '#888'; ctx.strokeRect(e.x + 8, e.y + 8, e.w - 16, e.h - 16);
                } else if (e.type === 'boss') {
                    ctx.fillStyle = '#43a047'; ctx.fillRect(e.x, e.y, e.w, e.h);
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 32px Arial'; ctx.fillText('BOSS', e.x + 18, e.y + e.h / 2 + 12);
                } else {
                    ctx.fillStyle = e.color; ctx.beginPath(); ctx.arc(e.x + e.w / 2, e.y + e.h / 2, e.w / 2, 0, 2 * Math.PI); ctx.fill();
                }
                ctx.restore();
                ctx.fillStyle = '#000'; ctx.fillRect(e.x, e.y - 8, e.w, 6);
                ctx.fillStyle = '#f00'; ctx.fillRect(e.x, e.y - 8, e.w * e.hp / e.maxHp, 6);
                // æ•Œäººå—å‡»é—ªçƒ
                if (e.hitFlash && e.hitFlash > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(e.x + e.w / 2, e.y + e.h / 2, e.w / 2 + 2, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.restore();
                    e.hitFlash--;
                }
                if (e.hp <= 0) {
                    // æ–°å¢ï¼šç²’å­çˆ†ç‚¸æ•ˆæœ
                    for (let p = 0; p < 12; p++) {
                        let angle = Math.random() * Math.PI * 2;
                        let speed = 2 + Math.random() * 2;
                        particles.push({
                            x: e.x + e.w / 2,
                            y: e.y + e.h / 2,
                            dx: Math.cos(angle) * speed,
                            dy: Math.sin(angle) * speed,
                            r: 3 + Math.random() * 2,
                            color: e.color,
                            life: 18 + Math.random() * 10,
                            maxLife: 18 + Math.random() * 10
                        });
                    }
                    spawnExp(e.x + e.w / 2, e.y + e.h / 2, e.type === 'boss' ? 30 : 3);
                    if (e.type === 'boss') bossActive = false;
                    enemies.splice(i, 1);
                    score += e.type === 'boss' ? 200 : 20;
                } else if (e.y > H + 40) {
                    enemies.splice(i, 1);
                    if (player.shield > 0) {
                        player.shield--;
                        // äº§ç”ŸæŠ¤ç›¾ç ´ç¢ç‰¹æ•ˆ
                    } else if (!player.invincible) {
                        player.hp--;
                        player.invincible = 60;
                    }
                }
            }
            // æ•Œäººå¼¹å¹•
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                let b = enemyBullets[i];
                b.x += b.dx * delta;
                b.y += b.dy * delta;
                ctx.fillStyle = '#ff0';
                ctx.fillRect(b.x, b.y, b.w, b.h);
                if (b.x + 8 > player.x && b.x < player.x + player.w && b.y + 16 > player.y && b.y < player.y + player.h) {
                    if (player.invincible <= 0) {
                        player.hp--;
                        player.invincible = 60;
                    }
                    enemyBullets.splice(i, 1);
                } else if (b.y > H + 20) {
                    enemyBullets.splice(i, 1);
                }
            }
            // ç»éªŒçƒ
            updateExp();
            for (let e of exps) {
                ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, 2 * Math.PI); ctx.fillStyle = '#4f8ef7'; ctx.fill(); ctx.strokeStyle = '#fff'; ctx.stroke();
            }
            // UI
            scoreSpan.textContent = `ç»©ç‚¹: ${score}`;
            levelSpan.textContent = `å¹´çº§: ${level}`;
            expSpan.textContent = `å­¦åˆ†: ${exp}/${expToLevel}`;
            waveSpan.textContent = `å­¦æœŸ: ${wave}`;
            hpSpan.textContent = `ä½“åŠ›: ${player.hp.toFixed(1)}/${player.maxHp}`;
            // æ­¦å™¨å‚æ•°æ 
            weaponContent.innerHTML = player.weapons.map(w => {
                let def = getWeaponDef(w.key);
                let crit = player.crit ? '10%' : (w.crit ? '10%' : '0%');
                let vamp = w.vamp ? 'æœ‰' : 'æ— ';
                let heal = player.healAura ? 'æœ‰' : 'æ— ';
                let rapid = player.rapid ? 'æœ‰' : 'æ— ';
                let expplus = player.skills && player.skills.includes('expPlus') ? 'æœ‰' : 'æ— ';
                let fireRateShow = (w.fireRate / (1 + (w.fireRateBonus || 0))).toFixed(2);
                let fireRateBonusShow = ((w.fireRateBonus || 0) * 100).toFixed(0) + '%';
                return `<div style="margin:0 0 8px 0;padding:6px;border-radius:8px;background:#e3eafc;border:1px solid #b0c4de;display:block;width:100%;">
                    <div style="font-size:16px;font-weight:bold;margin-bottom:4px;"><span style="font-size:18px;vertical-align:middle;">${ICONS[w.key] || 'âœ¨'}</span> ${w.name}</div>
                    <div style="font-size:11px;line-height:1.3;">
                        <div>ä¼¤å®³:<b>${w.damage}</b> å°„é€Ÿ:<b>${fireRateShow}</b> <span title='å°„é€ŸåŠ æˆ' style='color:#4caf50'>+${fireRateBonusShow}</span> å¼¹é“:<b>${w.count || 1}</b></div>
                        <div>æš´å‡»:<b>${crit}</b> å¸è¡€:<b>${vamp}</b></div>
                        <div>å›è¡€:<b>${heal}</b> è¿å°„:<b>${rapid}</b> ç»éªŒ:<b>${expplus}</b></div>
                    </div>
                </div>`;
            }).join('');
            // å®æ—¶è°ƒè¯•ä¿¡æ¯
            const fps = Math.round(1000 / ((now - lastFrameTime) || 16.67));
            const totalEnt = enemies.length + bullets.length + particles.length;
            weaponContent.innerHTML += `
            <div style="margin-top:6px;padding:4px 6px;background:#111;color:#0f0;font-family:monospace;font-size:10px;border-radius:4px;">
              FPS:${fps} | ENT:${totalEnt} | RAPID:${Math.ceil(player.rapid / 60)}s
            </div>`;
            // ç²’å­
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.dx * delta; p.y += p.dy * delta; p.life--;
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, 2 * Math.PI); ctx.fill(); ctx.globalAlpha = 1;
                if (p.life <= 0) particles.splice(i, 1);
            }
            // æ³¢æ¬¡ä¸Boss
            if (gameState === 'playing') {
                if (enemies.length < Math.min(8 + wave, 20)) {
                    if (wave % 5 === 0 && enemies.filter(e => e.type !== 'boss').length === 0) {
                        spawnBoss();
                    } else if (wave >= 6 && wave % 4 === 0 && enemies.length === 0 && !bossActive) {
                        for (let i = 0; i < wave * 2; i++) setTimeout(spawnEnemy, i * 200);
                    } else if (Math.random() < 0.04 * delta) {
                        spawnEnemy();
                    }
                }
                if (score > wave * 200) wave++;
            }
            if (player.hp <= 0) {
                showGameOver();
                return;
            }
            requestAnimationFrame(gameLoop);
        }

        // åˆ¤æ–­æ˜¯å¦ä¸ºç§»åŠ¨ç«¯
        function isMobile() {
            return /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent);
        }
        if (isMobile()) {
            document.getElementById('virtual-joystick').style.display = 'block';
        }

        // è™šæ‹Ÿæ–¹å‘é”®æ»‘åŠ¨é€»è¾‘
        const vj = document.getElementById('virtual-joystick');
        const vjBtns = document.querySelectorAll('.vj-btn');
        let vjActiveDir = null;

        function getDirFromTouch(touch) {
            for (const btn of vjBtns) {
                const rect = btn.getBoundingClientRect();
                if (
                    touch.clientX >= rect.left &&
                    touch.clientX <= rect.right &&
                    touch.clientY >= rect.top &&
                    touch.clientY <= rect.bottom
                ) {
                    return btn.getAttribute('data-dir');
                }
            }
            return null;
        }

        vj.addEventListener('touchstart', function (e) {
            const dir = getDirFromTouch(e.touches[0]);
            if (dir) {
                vjActiveDir = dir;
                keys[dirToKey(dir)] = true;
                updateVjActive();
            }
            e.preventDefault();
        }, { passive: false });

        vj.addEventListener('touchmove', function (e) {
            const dir = getDirFromTouch(e.touches[0]);
            if (dir !== vjActiveDir) {
                if (vjActiveDir) keys[dirToKey(vjActiveDir)] = false;
                if (dir) keys[dirToKey(dir)] = true;
                vjActiveDir = dir;
                updateVjActive();
            }
            e.preventDefault();
        }, { passive: false });

        vj.addEventListener('touchend', function (e) {
            if (vjActiveDir) keys[dirToKey(vjActiveDir)] = false;
            vjActiveDir = null;
            updateVjActive();
            e.preventDefault();
        }, { passive: false });

        function dirToKey(dir) {
            switch (dir) {
                case 'up': return 'ArrowUp';
                case 'down': return 'ArrowDown';
                case 'left': return 'ArrowLeft';
                case 'right': return 'ArrowRight';
            }
        }

        function updateVjActive() {
            vjBtns.forEach(btn => {
                btn.classList.toggle('active', btn.getAttribute('data-dir') === vjActiveDir);
            });
        }

        resetGame();
        requestAnimationFrame(gameLoop);

        // åº•éƒ¨æ–°å¢
        function revive() {
            if (score >= 10000) {
                score -= 10000;
                player.hp = player.maxHp;
                gameOverDiv.style.display = 'none';
                gameState = 'playing';
                lastFrameTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        }

        // åœ¨<script>å†…å¢åŠ showDamageå‡½æ•°
        function showDamage(x, y, dmg) {
            // è·å–canvasåœ¨é¡µé¢ä¸­çš„ä½ç½®
            const canvas = document.getElementById('game-canvas');
            const container = document.getElementById('game-container');
            const rect = canvas.getBoundingClientRect();
            const crect = container.getBoundingClientRect();

            // è®¡ç®—ç›¸å¯¹äºcanvaså·¦ä¸Šè§’çš„åæ ‡
            const relX = x + rect.left - crect.left;
            const relY = y + rect.top - crect.top;

            const span = document.createElement('div');
            span.textContent = '-' + dmg;
            span.style.cssText = `
                position:absolute;
                left:${relX - 24}px;
                top:${relY - 32}px;
                color:#fffa70;
                font-weight:bold;
                font-size:28px;
                pointer-events:none;
                animation:pop 1s forwards;
                z-index:99;
                text-shadow:0 0 8px #fff,0 0 2px #000,2px 2px 0 #000;
                filter:drop-shadow(0 0 6px #fff);
                user-select:none;
            `;
            container.appendChild(span);
            setTimeout(() => span.remove(), 1000);
        }

        // å¢å¼ºæ¿€å…‰æ•ˆæœ
        if (b.effect === 'laser') {
            ctx.save();
            // ä¸»ä½“æ¸å˜
            let grad = ctx.createLinearGradient(b.x + b.w / 2, player.y + player.h / 2, b.x + b.w / 2, 0);
            grad.addColorStop(0, '#fff');
            grad.addColorStop(0.2, '#39ff14');
            grad.addColorStop(1, 'rgba(57,255,20,0.1)');
            ctx.globalAlpha = 0.85;
            ctx.shadowColor = '#39ff14';
            ctx.shadowBlur = 36;
            ctx.strokeStyle = grad;
            ctx.lineWidth = 28;
            ctx.beginPath();
            ctx.moveTo(b.x + b.w / 2, player.y + player.h / 2);
            ctx.lineTo(b.x + b.w / 2, 0);
            ctx.stroke();
            // å†…æ ¸
            ctx.globalAlpha = 1;
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(b.x + b.w / 2, player.y + player.h / 2);
            ctx.lineTo(b.x + b.w / 2, 0);
            ctx.stroke();
            // æœ«ç«¯é«˜äº®ç²’å­
            ctx.save();
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(b.x + b.w / 2, 0, 18 + Math.random() * 6, 0, 2 * Math.PI);
            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#39ff14';
            ctx.shadowBlur = 32;
            ctx.fill();
            ctx.restore();
            ctx.restore();
        }
    </script>
</body>

</html>
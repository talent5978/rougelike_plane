<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>肉鸽飞机大战</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #111;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            margin: 0 auto;
            width: 480px;
            height: 700px;
            background: #222;
            border: 2px solid #fff;
        }

        canvas {
            display: block;
            background: #222;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 2;
            pointer-events: none;
        }

        #ui span {
            margin: 0 10px;
            font-size: 18px;
        }

        #upgrade-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 30, 30, 0.98);
            border: 2px solid #fff;
            border-radius: 10px;
            padding: 30px 20px 20px 20px;
            z-index: 10;
            display: none;
            min-width: 320px;
            text-align: center;
        }

        #upgrade-panel h2 {
            margin-top: 0;
        }

        .upgrade-option {
            background: #333;
            border: 1px solid #888;
            border-radius: 6px;
            margin: 10px 0;
            padding: 12px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.2s;
        }

        .upgrade-option:hover {
            background: #444;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #fff;
            border-radius: 10px;
            padding: 30px 40px;
            z-index: 20;
            display: none;
            text-align: center;
        }

        #game-over h2 {
            margin-top: 0;
        }

        #game-over button {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 18px;
            background: #4CAF50;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #game-over button:hover {
            background: #388e3c;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <canvas id="game-canvas" width="480" height="700"></canvas>
        <div id="ui">
            <span id="score">分数: 0</span>
            <span id="level">等级: 1</span>
            <span id="exp">经验: 0/10</span>
            <span id="wave">波次: 1</span>
            <span id="hp">生命: 3</span>
        </div>
        <div id="upgrade-panel">
            <h2>升级！请选择一项</h2>
            <div id="upgrade-options"></div>
        </div>
        <div id="game-over">
            <h2>游戏结束</h2>
            <div id="final-score"></div>
            <button onclick="restartGame()">重新开始</button>
        </div>
    </div>
    <!-- 虚拟按钮，仅在手机端显示 -->
    <div id="mobile-controls"
        style="display:none; position:absolute; left:0; bottom:0; width:100%; height:180px; z-index:30; pointer-events:none;">
        <div style="position:absolute; left:20px; bottom:20px; width:120px; height:120px;">
            <button class="mc-btn" id="btn-left" style="position:absolute; left:0; top:40px;">◀</button>
            <button class="mc-btn" id="btn-right" style="position:absolute; left:80px; top:40px;">▶</button>
            <button class="mc-btn" id="btn-up" style="position:absolute; left:40px; top:0;">▲</button>
            <button class="mc-btn" id="btn-down" style="position:absolute; left:40px; top:80px;">▼</button>
        </div>
        <button class="mc-btn" id="btn-shoot"
            style="position:absolute; right:30px; bottom:40px; width:80px; height:80px; font-size:28px;">射击</button>
    </div>
    <style>
        .mc-btn {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #fff;
            border-radius: 50%;
            color: #fff;
            font-size: 22px;
            margin: 0;
            pointer-events: auto;
            outline: none;
            user-select: none;
            transition: background 0.2s;
        }

        #btn-shoot {
            border-radius: 50%;
            background: rgba(255, 255, 0, 0.25);
            color: #222;
            font-weight: bold;
        }

        .mc-btn:active {
            background: #fff;
            color: #222;
        }

        @media (max-width: 700px) {
            #mobile-controls {
                display: block !important;
            }
        }
    </style>
    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        let lastFrameTime = performance.now();

        // UI
        const scoreSpan = document.getElementById('score');
        const levelSpan = document.getElementById('level');
        const expSpan = document.getElementById('exp');
        const waveSpan = document.getElementById('wave');
        const hpSpan = document.getElementById('hp');
        const upgradePanel = document.getElementById('upgrade-panel');
        const upgradeOptionsDiv = document.getElementById('upgrade-options');
        const gameOverDiv = document.getElementById('game-over');
        const finalScoreDiv = document.getElementById('final-score');

        // 游戏数据
        let player, bullets, enemies, enemyBullets, particles, upgrades, score, level, exp, expToLevel, wave, hp, gameState, upgradePool, lastUpgradeChoices, bossActive;

        function resetGame() {
            player = {
                x: W / 2 - 20, y: H - 80, w: 40, h: 40,
                speed: 3, // 降低速度
                fireRate: 12, // 帧
                fireTimer: 0,
                bulletCount: 1,
                bulletSpread: 0,
                bulletDamage: 1,
                bulletSpeed: 5, // 降低速度
                pierce: 0,
                hp: 3,
                invincible: 0,
                magnet: false,
                magnetRange: 0,
                skills: [],
                homing: false, // 追踪弹标记
            };
            bullets = [];
            enemies = [];
            enemyBullets = [];
            particles = [];
            upgrades = [];
            score = 0;
            level = 1;
            exp = 0;
            expToLevel = 10;
            wave = 1;
            hp = 3;
            gameState = 'playing';
            bossActive = false;
            upgradePool = [
                { name: '增加子弹数量', desc: '每次射击多发一颗子弹', apply: p => p.bulletCount += 1 },
                { name: '提升射速', desc: '射击间隔-2帧', apply: p => p.fireRate = Math.max(3, p.fireRate - 2) },
                { name: '提升子弹威力', desc: '子弹伤害+1', apply: p => p.bulletDamage += 1 },
                { name: '提升子弹速度', desc: '子弹飞行速度+2', apply: p => p.bulletSpeed += 2 },
                { name: '提升移动速度', desc: '飞机移动速度+0.5', apply: p => p.speed += 0.5 },
                { name: '子弹穿透', desc: '子弹可多穿透1个敌人', apply: p => p.pierce += 1 },
                { name: '生命+1', desc: '最大生命+1', apply: p => { p.hp += 1; hp += 1; } },
                { name: '磁铁', desc: '自动吸取经验球', apply: p => { p.magnet = true; p.magnetRange = 120; } },
                { name: '散射', desc: '子弹发射角度+10°', apply: p => p.bulletSpread += 10 },
                { name: '爆炸弹', desc: '子弹击杀敌人时造成小范围溅射', apply: p => p.skills.push('explosive') },
                { name: '回血', desc: '每升级回复1点生命', apply: p => p.skills.push('healOnLevel') },
                { name: '护盾', desc: '获得一次无敌护盾', apply: p => p.invincible = 60 },
                { name: '追踪弹', desc: '子弹会自动追踪最近的敌人', apply: p => p.homing = true },
            ];
            lastUpgradeChoices = [];
        }

        function randomUpgradeChoices(n = 3) {
            let pool = upgradePool.filter(u => !lastUpgradeChoices.includes(u));
            if (pool.length < n) pool = upgradePool;
            let arr = [];
            while (arr.length < n) {
                let idx = Math.floor(Math.random() * pool.length);
                if (!arr.includes(pool[idx])) arr.push(pool[idx]);
            }
            lastUpgradeChoices = arr;
            return arr;
        }

        function showUpgradePanel() {
            upgradePanel.style.display = 'block';
            upgradeOptionsDiv.innerHTML = '';
            let choices = randomUpgradeChoices();
            choices.forEach(upg => {
                let div = document.createElement('div');
                div.className = 'upgrade-option';
                div.innerHTML = `<b>${upg.name}</b><br><small>${upg.desc}</small>`;
                div.onclick = () => {
                    upg.apply(player);
                    if (player.skills.includes('healOnLevel') && hp < player.hp) hp++;
                    upgradePanel.style.display = 'none';
                    gameState = 'playing';
                    lastFrameTime = performance.now(); // 避免deltaTime跳变
                    requestAnimationFrame(gameLoop);
                };
                upgradeOptionsDiv.appendChild(div);
            });
            gameState = 'upgrade';
        }

        function showGameOver() {
            gameOverDiv.style.display = 'block';
            finalScoreDiv.innerHTML = `本局分数：${score}<br>等级：${level}`;
            gameState = 'over';
        }

        function restartGame() {
            gameOverDiv.style.display = 'none';
            resetGame();
            requestAnimationFrame(gameLoop);
        }

        // 控制
        let keys = {};
        document.addEventListener('keydown', e => { keys[e.key] = true; });
        document.addEventListener('keyup', e => { keys[e.key] = false; });

        // 经验球
        let exps = [];
        function spawnExp(x, y, amount = 1) {
            for (let i = 0; i < amount; i++) {
                exps.push({ x: x + Math.random() * 20 - 10, y: y + Math.random() * 20 - 10, r: 6, v: 1 + Math.random() * 1.5, angle: Math.random() * Math.PI * 2 });
            }
        }

        function updateExp() {
            for (let i = exps.length - 1; i >= 0; i--) {
                let e = exps[i];
                if (player.magnet && Math.hypot(e.x - player.x - player.w / 2, e.y - player.y - player.h / 2) < player.magnetRange) {
                    let dx = player.x + player.w / 2 - e.x, dy = player.y + player.h / 2 - e.y;
                    let d = Math.hypot(dx, dy);
                    e.x += dx / d * 4;
                    e.y += dy / d * 4;
                } else {
                    e.y += e.v;
                }
                // 吸收
                if (Math.abs(e.x + e.r / 2 - player.x - player.w / 2) < player.w / 2 && Math.abs(e.y + e.r / 2 - player.y - player.h / 2) < player.h / 2) {
                    exp++;
                    exps.splice(i, 1);
                    if (exp >= expToLevel) {
                        exp -= expToLevel;
                        level++;
                        expToLevel = 10 + level * 3;
                        showUpgradePanel();
                    }
                } else if (e.y > H + 20) {
                    exps.splice(i, 1);
                }
            }
        }

        // 敌人生成
        function spawnEnemy() {
            let t = wave;
            let type = 'normal';
            let hp = 2 + t + Math.floor(Math.random() * t / 2);
            let speed = 2 + Math.random() * t / 4;
            let color = '#f44';
            if (t > 3 && Math.random() < 0.2) { type = 'fast'; speed += 2; color = '#ff0'; }
            if (t > 5 && Math.random() < 0.15) { type = 'tank'; hp += 5; color = '#0af'; }
            if (t > 7 && Math.random() < 0.1) { type = 'split'; color = '#fff'; }
            if (t > 10 && Math.random() < 0.08) { type = 'elite'; hp += 10; speed += 1; color = '#0f0'; }
            let x = Math.random() * (W - 40);
            enemies.push({ x, y: -40, w: 40, h: 40, hp, maxHp: hp, speed, type, color, split: 0 });
        }

        function spawnBoss() {
            bossActive = true;
            let hp = 60 + wave * 15;
            enemies.push({ x: W / 2 - 60, y: -120, w: 120, h: 120, hp, maxHp: hp, speed: 1.5 + wave / 8, type: 'boss', color: '#f0f', split: 0 });
        }

        // 游戏主循环
        document.addEventListener('visibilitychange', () => { if (document.hidden && gameState === 'playing') gameState = 'pause'; });
        function gameLoop(now) {
            if (gameState === 'over') return;
            if (gameState === 'pause') { requestAnimationFrame(gameLoop); return; }
            if (gameState === 'upgrade') return; // 升级时暂停一切
            let delta = (now - lastFrameTime) / 16.67; // 60fps基准
            lastFrameTime = now;
            // 背景
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, W, H);
            // 星星
            for (let i = 0; i < 40; i++) {
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.beginPath();
                ctx.arc(Math.random() * W, Math.random() * H, Math.random() * 1.5 + 0.5, 0, 2 * Math.PI);
                ctx.fill();
            }
            // 玩家
            ctx.save();
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#0ff';
            ctx.fillRect(player.x, player.y, player.w, player.h);
            ctx.restore();
            // 玩家无敌闪烁
            if (player.invincible > 0) {
                ctx.globalAlpha = 0.5 + 0.5 * Math.sin(Date.now() / 80);
                ctx.fillStyle = '#fff';
                ctx.fillRect(player.x, player.y, player.w, player.h);
                ctx.globalAlpha = 1;
                player.invincible--;
            }
            // 玩家移动
            if (gameState === 'playing') {
                let move = player.speed * delta;
                if (keys['ArrowLeft'] || keys['a']) player.x = Math.max(0, player.x - move);
                if (keys['ArrowRight'] || keys['d']) player.x = Math.min(W - player.w, player.x + move);
                if (keys['ArrowUp'] || keys['w']) player.y = Math.max(0, player.y - move);
                if (keys['ArrowDown'] || keys['s']) player.y = Math.min(H - player.h, player.y + move);
            }
            // 玩家射击
            if (player.fireTimer <= 0 && gameState === 'playing') {
                let spread = player.bulletSpread;
                let cnt = player.bulletCount;
                for (let i = 0; i < cnt; i++) {
                    let angle = (-(cnt - 1) / 2 + i) * spread * Math.PI / 180;
                    let dx = Math.sin(angle) * player.bulletSpeed;
                    let dy = -player.bulletSpeed * Math.cos(angle);
                    bullets.push({ x: player.x + player.w / 2 - 6, y: player.y - 12, w: 12, h: 24, dx, dy, damage: player.bulletDamage, pierce: player.pierce, explosive: player.skills.includes('explosive'), homing: player.homing });
                }
                player.fireTimer = player.fireRate;
            } else {
                player.fireTimer -= delta;
            }
            // 子弹
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                // 追踪弹逻辑
                if (b.homing && enemies.length > 0) {
                    let nearest = null, minDist = 1e9;
                    for (let e of enemies) {
                        let d = Math.hypot(e.x + e.w / 2 - b.x, b.y - (e.y + e.h / 2));
                        if (d < minDist) { minDist = d; nearest = e; }
                    }
                    if (nearest) {
                        let tx = nearest.x + nearest.w / 2, ty = nearest.y + nearest.h / 2;
                        let angle = Math.atan2(ty - b.y, tx - b.x);
                        let speed = Math.sqrt(b.dx * b.dx + b.dy * b.dy);
                        b.dx = Math.cos(angle) * speed;
                        b.dy = Math.sin(angle) * speed;
                    }
                }
                b.x += b.dx * delta;
                b.y += b.dy * delta;
                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    let e = enemies[j];
                    if (b.x + b.w > e.x && b.x < e.x + e.w && b.y + b.h > e.y && b.y < e.y + e.h) {
                        e.hp -= b.damage;
                        if (b.explosive) {
                            for (let k = enemies.length - 1; k >= 0; k--) {
                                let ee = enemies[k];
                                if (ee !== e && Math.hypot(ee.x - e.x, ee.y - e.y) < 50) ee.hp -= Math.ceil(b.damage / 2);
                            }
                        }
                        if (b.pierce > 0) { b.pierce--; continue; } else { hit = true; break; }
                    }
                }
                if (b.y < -30 || b.x < -30 || b.x > W + 30 || hit) bullets.splice(i, 1);
            }
            // 子弹绘制
            for (let b of bullets) {
                ctx.save();
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 8;
                ctx.fillStyle = '#fff';
                ctx.fillRect(b.x, b.y, b.w, b.h);
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#ff0';
                ctx.strokeRect(b.x, b.y, b.w, b.h);
                ctx.restore();
            }
            // 敌人
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                e.y += e.speed * delta;
                // Boss特殊弹幕
                if (e.type === 'boss' && Math.random() < 0.03 * delta) {
                    let bx = e.x + e.w / 2 - 8, by = e.y + e.h - 10;
                    for (let k = -2; k <= 2; k++) {
                        enemyBullets.push({ x: bx, y: by, w: 8, h: 16, dx: k * 2, dy: 3, damage: 1 });
                    }
                }
                // 分裂怪
                if (e.type === 'split' && e.hp <= e.maxHp / 2 && !e.split) {
                    e.split = 1;
                    for (let k = 0; k < 2; k++) {
                        enemies.push({ x: e.x + Math.random() * 20 - 10, y: e.y + Math.random() * 20 - 10, w: 28, h: 28, hp: Math.floor(e.maxHp / 2), maxHp: Math.floor(e.maxHp / 2), speed: e.speed + 0.5, type: 'normal', color: '#fff', split: 0 });
                    }
                }
                // 绘制
                ctx.save();
                ctx.shadowColor = e.color;
                ctx.shadowBlur = 10;
                ctx.fillStyle = e.color;
                ctx.fillRect(e.x, e.y, e.w, e.h);
                ctx.restore();
                // 血条
                ctx.fillStyle = '#000';
                ctx.fillRect(e.x, e.y - 8, e.w, 6);
                ctx.fillStyle = '#f00';
                ctx.fillRect(e.x, e.y - 8, e.w * e.hp / e.maxHp, 6);
                // 死亡
                if (e.hp <= 0) {
                    spawnExp(e.x + e.w / 2, e.y + e.h / 2, e.type === 'boss' ? 30 : 3);
                    if (e.type === 'boss') bossActive = false;
                    enemies.splice(i, 1);
                    score += e.type === 'boss' ? 200 : 20;
                } else if (e.y > H + 40) {
                    enemies.splice(i, 1);
                    hp--;
                }
            }
            // 敌人弹幕
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                let b = enemyBullets[i];
                b.x += b.dx * delta;
                b.y += b.dy * delta;
                ctx.fillStyle = '#ff0';
                ctx.fillRect(b.x, b.y, b.w, b.h);
                if (b.x + 8 > player.x && b.x < player.x + player.w && b.y + 16 > player.y && b.y < player.y + player.h) {
                    if (player.invincible <= 0) {
                        hp--;
                        player.invincible = 60;
                    }
                    enemyBullets.splice(i, 1);
                } else if (b.y > H + 20) {
                    enemyBullets.splice(i, 1);
                }
            }
            // 经验球
            updateExp();
            for (let e of exps) {
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.r, 0, 2 * Math.PI);
                ctx.fillStyle = '#0ff';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.stroke();
            }
            // UI
            scoreSpan.textContent = `分数: ${score}`;
            levelSpan.textContent = `等级: ${level}`;
            expSpan.textContent = `经验: ${exp}/${expToLevel}`;
            waveSpan.textContent = `波次: ${wave}`;
            hpSpan.textContent = `生命: ${hp}`;
            // 粒子
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.dx * delta; p.y += p.dy * delta; p.life--;
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r, 0, 2 * Math.PI);
                ctx.fill();
                ctx.globalAlpha = 1;
                if (p.life <= 0) particles.splice(i, 1);
            }
            // 波次与Boss
            if (gameState === 'playing') {
                if (enemies.length < Math.min(6, wave + 2) && !bossActive) {
                    if (wave % 5 === 0 && enemies.length === 0) {
                        spawnBoss();
                    } else if (Math.random() < 0.04 * delta) {
                        spawnEnemy();
                    }
                }
                if (score > wave * 200) wave++;
            }
            // 死亡
            if (hp <= 0) {
                showGameOver();
                return;
            }
            requestAnimationFrame(gameLoop);
        }

        resetGame();
        requestAnimationFrame(gameLoop);

        // 虚拟按钮支持
        function setupMobileControls() {
            const isMobile = window.innerWidth <= 700;
            const mc = document.getElementById('mobile-controls');
            if (!mc) return;
            if (isMobile) mc.style.display = 'block';
            else mc.style.display = 'none';
            // 按钮与 keys 映射
            const map = [
                ['btn-left', 'ArrowLeft'],
                ['btn-right', 'ArrowRight'],
                ['btn-up', 'ArrowUp'],
                ['btn-down', 'ArrowDown'],
                ['btn-shoot', ' '],
            ];
            map.forEach(([id, key]) => {
                const btn = document.getElementById(id);
                if (!btn) return;
                btn.ontouchstart = e => { e.preventDefault(); keys[key] = true; };
                btn.ontouchend = e => { e.preventDefault(); keys[key] = false; };
                btn.onmousedown = e => { keys[key] = true; };
                btn.onmouseup = e => { keys[key] = false; };
                btn.onmouseleave = e => { keys[key] = false; };
            });
            // 防止页面滚动
            mc.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        }
        window.addEventListener('resize', setupMobileControls);
        window.addEventListener('DOMContentLoaded', setupMobileControls);
    </script>
</body>

</html>